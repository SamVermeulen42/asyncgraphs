{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AsyncGraphs","text":"<p>AsyncGraphs is a tiny ETL framework that leverages asyncio to make the execution concurrent whilst blocked on I/O.</p> <p>Source: https://github.com/SamVermeulen42/asyncgraphs</p> <p>Documentation: https://samvermeulen42.github.io/asyncgraphs/</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed</li> <li>Simple concurrency based on asyncio</li> <li>Easy construction of ETL graphs</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install asyncgraphs\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>The following example prints random Pok\u00e9mon and the games they appear in.</p> <p>It does this every 10 seconds and uses Pok\u00e9Api.</p> <pre><code>import aiohttp\nfrom asyncgraphs import Graph, run\nimport asyncio\nfrom functools import partial\nfrom random import randint\nfrom typing import Dict, Any\n\n\nasync def random_pokemon_id():\n    while True:\n        yield randint(1, 151)\n        await asyncio.sleep(10)\n\nasync def get_pokemon_info(session: aiohttp.ClientSession, pokemon_id: int) -&gt; Dict[str, Any]:\n    pokemon_url = f\"https://pokeapi.co/api/v2/pokemon/{pokemon_id}\"\n    async with session.get(pokemon_url) as response:\n        yield await response.json()\n\ndef format_pokemon(pokemon_info: Dict[str, Any]) -&gt; str:\n    name = pokemon_info[\"name\"]\n    versions = (game['version']['name'] for game in pokemon_info['game_indices'])\n    return f\"{name}: {', '.join(versions)}\"\n\nasync def main():\n    async with aiohttp.ClientSession() as session:\n        g = Graph()\n        g | random_pokemon_id() | partial(get_pokemon_info, session) | format_pokemon | print\n        await run(g)\n\nasyncio.run(main())\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>This is a placeholder.</p> <p>Once the first alpha version is released, this will be maintained.</p>"},{"location":"components/graph/","title":"Graph","text":"<p>A graph object represents an entire ETL flow. It consists of sources and transforms.</p>"},{"location":"components/source/","title":"Source","text":"<p>A source in AsyncGraphs is a Node that simply generates data.</p> <p>Sources are attached directly to Graph objects and take no input.</p> <p>Any python Iterable or AsyncIterable can be used.</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\n\ng | [1, 2, 3]\n</code></pre> <pre><code>from asyncgraphs import Graph\nfrom random import random\n\ng = Graph()\n\ng | (random() for _ in range(10))\n</code></pre> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\n\ndef my_source():\n    for i in range(1000):\n        yield {\"number\": i}\n\ng | my_source()\n</code></pre> <pre><code>import asyncio\nfrom asyncgraphs import Graph\nimport aiohttp\n\ng = Graph()\n\n\nasync def my_source(session):\n    while True:\n        async with session.get('http://localhost:8000') as response:\n            response.raise_for_status()\n            yield await response.json()\n        await asyncio.sleep(10)\n\nasync def main():\n    async with aiohttp.ClientSession() as session:\n        g | my_source(session)\n</code></pre>"},{"location":"components/transform/","title":"Transform","text":"<p>Transformations (and data sinks) are always of type Callable. As an argument they take 1 output value of the previous step in the graph.</p> <p>The functions can be async (which is preferred if the task can be done asynchronously). There are 2 ways of implementing the transformation:</p> <ul> <li>1 doc in = 1 doc out: return the output document</li> <li>1 doc in = 0 or more docs out: use the yield keyword to yield the documents that should be outputted by the transformation</li> </ul> <p>Example of a 1 to 1 transform:</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\n\ndef add_one(input: int) -&gt; int:\n    return input + 1\n\n\ng | [1, 2, 3] | add_one | print\n</code></pre> <p>For a 1 to any transform, use yields:</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\n\ndef repeat_hello(input: int) -&gt; str:\n    for _ in range(input):\n        yield \"hello\"\n\n\ng | [0, 1, 2, 3] | repeat_hello | print\n</code></pre>"},{"location":"usage/construction/","title":"Construction","text":"<p>Graph construction start with a Graph object.</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\n</code></pre> <p>This graph acts as the handle for your entire ETL operation.</p>"},{"location":"usage/construction/#adding-a-source","title":"Adding a source","text":"<p>An ETL graph needs nodes and the first nodes that are needed are source nodes. More information on the operations that can be used as a source can be found on the source page.</p> <p>Adding sources to the ETL flow is done by linking it to the Graph object. This can be done in a couple of ways. The following example shows them.</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\ng.link_to([1, 2, 3])\ng &gt;&gt; [4, 5, 6]\ng | [7, 8, 9]\n</code></pre> <p>In the example above there are 3 different source nodes in the graph, each emitting values from a fixed list.</p>"},{"location":"usage/construction/#adding-a-transform-or-sink","title":"Adding a transform (or sink)","text":"<p>All nodes that are not a source are considered a transform. Transform nodes take in data and optionally emit data.</p> <p>The same methods and operators can be used to attach transformations to a source.</p> <pre><code>from asyncgraphs import Graph\n\ng = Graph()\nsource_ref = g | [1, 2, 3]\nsource_ref | (lambda x: x + 1) | print\n</code></pre>"},{"location":"usage/execution/","title":"Execution","text":"<p>Executing a Graph can be done by calling <code>run(graph)</code>.</p> <p>As an example, let's look at what happens when executing the following graph.</p> <pre><code>from asyncgraphs import Graph, run\n\ng = Graph()\ntransformed = g | [1, 2, 3] | (lambda x: x + 1)\ntransformed | (lambda x: x * 2) | (lambda x: print(f\"Doubled: {x}\"))\ntransformed | (lambda x: print(f\"Regular: {x}\"))\n\nawait run(g)\n</code></pre> <p>The graph thus looks like this:</p> <pre><code>flowchart LR\n    Source[\"[1, 2, 3]\"]\n    AddOne[\"x + 1\"]\n    Double[\"x * 2\"]\n    PrintDouble[\"print(f#quot;Doubled: {x}#quot;)\"]\n    PrintRegular[\"print(f#quot;Regular: {x}#quot;)\"]\n\n    Source --&gt; AddOne\n    AddOne --&gt; Double --&gt; PrintDouble\n    AddOne --&gt; PrintRegular</code></pre> <p>When calling <code>run(g)</code>, this library adds asyncio Queues between each pair of nodes. At runtime, this is the graph:</p> <pre><code>flowchart LR\n    Source[\"[1, 2, 3]\"]\n    AddOne[\"x + 1\"]\n    Double[\"x * 2\"]\n    PrintDouble[\"print(f#quot;Doubled: {x}#quot;)\"]\n    PrintRegular[\"print(f#quot;Regular: {x}#quot;)\"]\n\n\n    Source --&gt; SourceQ([Queue]) --&gt; AddOne\n    AddOne --&gt; DoubleQ([Queue]) --&gt; Double --&gt; PrintDoubleQ([Queue]) --&gt; PrintDouble\n    AddOne --&gt; PrintRegularQ([Queue]) --&gt; PrintRegular</code></pre>"},{"location":"usage/execution/#concurrency","title":"Concurrency","text":""},{"location":"usage/execution/#inter-node-concurrency","title":"Inter-node concurrency","text":"<p>There is concurrency between nodes.  When the execution of 1 node is blocked by I/O, other nodes get to process their input events.</p>"},{"location":"usage/execution/#intra-node-concurrency","title":"Intra-node concurrency","text":"<p>Currently, intra-node concurrency (a.k.a processing handling multiple events in 1 node concurrently) is not supported.</p> <p>This will be implemented in this ticket.</p>"}]}